7章 キャンセルとシャットダウン
------------

* Javaにはタスクを協力的にインタラプトする仕組みが存在する  
 * 瞬時に、急停止しなければならないシチュエーションは少ない  
 * 基本は後処理を経て停止されるべき

7-1 タスクのキャンセル
------------
* キャンセルの一番簡単な方法
 * キャンセルフラグをタスクに持たせる  
 * // TODO コードのURL  

* キャンセルされる側のタスクは、キャンセルの(how,when,what)を定義した、キャンセルポリシーを必ず持つ必要がある
 * タスクをどうやって(how)キャンセルするのか  
 * タスクをいつ(when)キャンセルするのか  
 * タスクのキャンセルに対してどんな(what)アクションを行うのか  

## 7-1-1 インタラプション
* 以下の例は、ブロッキングキューが満杯でputで処理待ちしている場合、キャンセルできない
 * // TODO コードのURL  
 * Javaのブロックメソッドはインタラプトをサポートしているので、それを使おう  

### JavaのThreadクラスのメソッドたち
| メソッド | 内容 |
|----------|--------------------------------|
| void interrupt() | インタラプテッドステータスをtrueにする |
| boolean isInterrupted() | 現在のインタラプテッドステータスを取得する |               
| static boolean interrupted() | 現在のスレッド（このメソッドを呼んだスレッド）のインタラプテッドステータスをクリアし、その前の値を返す |

### Threadインタラプションとは
* 実行中のスレッドに対して、割り込みをする訳ではない  
* 「あなたのご都合のよろしいときにお仕事を中断してください」とリクエストするだけ  
* 実際の処理はメソッドにゆだねられている  
 * 例外を投げる
  * リクエストは無視するがインタラプテッドステータスは保持して呼び出し側に処理をゆだねる
  * 完全無視(行儀わるい)  
  * など

## 7-1-2 インタラプションポリシー
* タスクはキャンセルポリシーを持つべきだが、 **スレッドはインタラプションポリシーを持つべき**
* タスクは基本的には自らのスレッドをもたないので、”ゲスト”である自分自身はインタラプションポリシーを持つべきではない  

### (例) ブロック系のライブラリ(Thread.sleep()とか)
* 一番リーズナブルなキャンセルポリシーを適応  
 * インタラプトを検知した場合は、InterruptedExceptionをthrowして呼び出し側にインタラプトを伝搬する  
* インタラプトを検知した場合の処理はいろいろある  
 * データの整合性を保持できるように処理した後に例外を投げる  
 * InterruptExceptionを投げられない場合はThread.currentThread().interrupt()でインタラプテッドステータスを保全する  
 * など  

- - -
**各スレッドに自分のインタラプションポリシーがあるので、（あなたが書く）タスクは、インタラプションがそのスレッドに取ってどんな意味があるのかを知っている場合意外は、スレッドにインタラプトしてはいけません。**
- - - 

➡　つまりインタラプトをどうするかはディベロッパーの自由

## 7-1-3 インタラプションへの応答
### InterruptionExceptionへの代表的な対応方法
* 例外を広める(呼び出し側に渡す)
* インタラプテッドステータスを復元して呼び出し、スタックの上の方がそれを処理するように書く
 * Thread#interrupted()  

- - -
**自分がどのスレッドで動かされているかが分からない場合(インタラプションポリシーを判定できない場合)、インタラプトをもみ消してはダメです！！**
- - -
